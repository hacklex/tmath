---
marp: true
math: katex
---

# Исчисление выражений

---

# Функции

---

В школьной математике они определялись правилами вида

$$l(x) := 3x - 2$$

И вычислислялись с помощью подстановки:

$$\begin{aligned}
l(1) &= 3 - 2 = 1 \\
l(5) &= 15 - 2 = 13
\end{aligned}$$

Функции, вычисляемые с помощью подстановки, станут нашим основным инструментом.

---

Но сначала нужно отделить вычисление от равенства.

Запись ${\color{red}e_1} \xrightarrow{*} {\color{red}e_2}$ означает, что результатом применения нуля или более числа шагов вычисления к ${\color{red}e_1}$ является выражение ${\color{red}e_2}$.

Пример:

$$l(3) \xrightarrow{*} 3\cdot3 - 2 \xrightarrow{*} 9 - 2 \xrightarrow{*} 7$$

Знак вычисления — метасимвол, не являющийся частью выражения.

---

Отделив вычисление от равенства, мы может рассматривать равенство как высказывание, которое может быть как истиным, так и ложным.

Например, $1=1$ это истинное высказывание, когда же $2=3$ — ложное высказывание.

Как и остальные выражения, равенства можно вычислять:

$$(2\cdot 3 = 7-1) \xrightarrow{*} (6 = 7-1) \xrightarrow{*} (6=6)$$

---

То, что равенство это выражение, позволяет сопоставить каждому уравнению функцию, которая подставляет значения в уравнение.

Например, для уравнения $x^2 - 3x + 2 = 0$ такой функцией будет
$$eq(x) := (x^2 - 3x + 2 = 0)$$

---

Применяя $eq$ к различным значениям $x$, получаем различные высказывания. Некоторые из них являются истиными:

$$eq(1) \xrightarrow{*} (1 - 3 + 2 = 0) \xrightarrow{*} (0 = 0) \\
eq(2) \xrightarrow{*} (4 - 6 + 2 = 0) \xrightarrow{*} (0 = 0)$$

Остальные — ложными:

$$\begin{aligned}
eq(0) &\xrightarrow{*} (2 = 0) \\
eq(3) &\xrightarrow{*} (9 - 9 + 2 = 0) \xrightarrow{*} (2=0)
\end{aligned}$$

Значение $x$ является решением уравнения $eq$ в том случае, когда высказывание $eq(x)$ истино.

---

Тождества отличаются от уравнений тем, что они истины для всех возможных аргументов.

Например, возьмём коммутативность сложения:

$$comm(x,y) := (x+y = y+x)$$

Значение функции $comm$ истино для всех числовых значений $x$ и $y$.

---

Подстановка называется вычислением не просто так — с помощью функций можно выражать и алгоритмы, в том числе и арифметические операции.

Основная идея — свести задачу к той же задаче, но с другимы данными.

---

Рассмотрим сложение чисел используя камешки. Пусть есть два мешка — в левом три камня, когда же в правом — два. Мы хотим найти сумму этих камней:

$$\{\bullet{\bullet}\bullet\} + \{\bullet\bullet\}$$

Переложив камешек из правого мешка в левый, получаем другую задачу:

$$\{\bullet{\bullet}{\bullet}\bullet\} + \{\bullet\}$$

Переложив ещё один, получаем:

$$\{\bullet{\bullet}{\bullet}{\bullet}\bullet\} + \{\}$$

И здесь мы уже знаем ответ: $\{\bullet{\bullet}{\bullet}{\bullet}\bullet\}$.

---

Символьно же, мы выражаем натуральные числа следующим образом:

$$\begin{aligned}
&0 & &1 & &2 & &3 & &\dots \\
&z & &s(z) & &s(s(z)) & &s(s(s(z))) & &\dots
\end{aligned}$$

Константа $z$ означает нуль, когда же $s(n)$ означает число, которое непосредственно следует за числом $n$.

$s$ можно рассматривать как функцию — но мы её не вычисляем, а используем выражение буквально.

---

Функцию $(+)(n, k)$ можно опредеить как

$$\begin{aligned}
n + z  &:= n \\
n + s(k)  &:= s(n) + k
\end{aligned}$$

Функция $(+)$ использует саму себя в своём определении. Такие функции называются *рекурсивными*, а непосредственно ссылка функции на себя — *рекурсией*.

---

Вычислим $3+2$, используя данное нами определение сложение:

$$\begin{aligned}
    s(s(s(0)))   + s(s(0)) &\xrightarrow{*}  s(s(s(s(0))))  +   s(0) \\
  &\xrightarrow{*} s(s(s(s(s(0))))) +     0 \\
  &\xrightarrow{*} s(s(s(s(s(0)))))
\end{aligned}$$

Не самый эффективный способ складывать числа, но как пример сойдёт.

---

Но вычислять можно не только равенства и числа, но даже сами функции. Для этого введём понятие анонимной функции.

Анонимная функция, которая сопоставляет числу его квадрат пишется так:

$$λn.\; n^2$$

И применяется точно так же, как и обычная функция:

$$(λn.\; n^2)(3) \xrightarrow{*} 3^2 \xrightarrow{*} 9$$

---

Определим функцию $add$, результатом которой является функция, которая прибавляет число:

$$add(n) := λk.\;n+k$$

С её помощью можно сложить два числа:

$$add(3)(4) \xrightarrow{*} (λk.\; 3+k)(4) \xrightarrow{*}7$$

Любую функцию нескольких аргументов можно представить как функцию одного аргумента, результатом которой является другая функция.

---

# Лямбда-исчисление

---

Лямбда-исчисление это анонимные функции превращённые в формальную систему. Синтаксис:

$$\begin{aligned}
expr ::=\ &var & &\text{(имя переменной)} \\
\mid\quad &“λ” \, var\ “.”\ expr & &\text{(абстракция)} \\
\mid\quad &expr\ expr & &\text{(применение)}
\end{aligned}$$

Имя переменной может содержать более одного символа. Кроме того, мы различаем строчные буквы от заглавных: $ab$ и $aB$ это два разных имени.

Применение левоассоциативно: $\color{red} f\ v_1\ v_2$ означает $({\color{red} f\ v_1})\ {\color{red}v_2}$. Кроме того, абстракция захватывает всё, что находится справа её.

---

Ещё мы будем использовать следующее сокращение:
- ${λ\color{red} v_1\, v_2}.\; \color{red}e$ означает $λ\textcolor{red}{v_1}.\;(λ\textcolor{red}{v_2}.\; \textcolor{red}{e})$.
- $λ{\color{red} v_1\,v_2\,v_3}.\; \textcolor{red}e$ означает $λ\textcolor{red}{v_1}.\;(λ\textcolor{red}{v_2}.\; (λ\textcolor{red}{v_3}.\;\textcolor{red}e))$.
- И так далее

Например, $λ x\, y.\; x$ это то же самое, что и $λx.\; λ y.\; x$.

---

Предназначение переменных — указывать места для подстановки. Однако, наличие имён у переменных порождает проблемы.

Например, что означает $λx.\; λx.\; x$?

---

Чтобы сделать имена однозначными, пронумеруем их. Для этого, двигаясь *вниз* по синтаксическому дереву, пронумеруем переменные при абстракция в порядке их появления. При этом переменные нумеруются независимо в каждом пути дерева.

Затем для каждой переменной вне абстракции, двигаясь *вверх* по синтаксическому дереву, ищем ближайшую абстракцию, в которой переменная имеет то же имя. Если такая такая абстракция нашлась, то нумеруем изначальную переменную соответствующим номером.

---

Пронумеровав $λx.\; λx.\; x$, получаем $λx^0.\; λx^1.\; x^1$. Здесь явно видно, что переменная $x$ связана с внутренней абстракцией, а не с внешней.

Другой пример. Рассмотрим выражение

$$λf.\; (λx.\; x)\ (λy.\; y)\ (λz.\; w)$$

Пронумерованное выражение имеет вид

$$λf^0.\; (λx^1.\; x^1)\ (λy^1.\; y^1)\ (λz^1.\; w)$$

Следующий слайд показывает синтаксическое дерево этого выражения.

---

![bg fit](./images/level-tree.png)

---

Классификация переменных в пронумерованном выражении:

1. Вхождение переменной при абстракции называется связывающим
2. Вхождения пронумерованных переменных называются связанными
3. Вхождения переменных без номеров называются свободными

Связанные вхождения указывают места для подстановки значений, когда же свободные переменные можно рассматривать как внешние определения.

---

Номера сами по себе однозначно указывают места подстановки. Заменив связанные вхождения на номера и удалив связывающие вхождения, получаем локально безымянное предствление.

Вот несколько выражений в локально безымянном предствлении:

$$\begin{aligned}
&λx.\;x &\qquad &λ.\; \underline 0 \\
&λx.\;λy.\;y & &λ.\; λ.\ \underline 1 \\
&(λx.\;λy.\; y\ x)\ z & &(λ.\;λ.\; \underline 1\ \underline 0)\ z
\end{aligned}$$

---

Выражения $\color{red}e_1$ и $\color{red}e_2$ называются альфа-эквивалентными (пишется $\textcolor{red}{e_1} \equiv_α \textcolor{red}{e_2}$), если их локально безымянные формы совпадает.

Альфа-эквивалентность выражает то, что смысл выражения не зависит от имён связанных переменных: например, $λx.\;x$ и $λt.\;t$ это по сути одно и то же выражение.

Далее, мы будем считать альфа-эквивалентные выражения одним и тем же выражением.

---

Если свободная переменная это внешнее определение, то можно подставить значение на её место.

$\textcolor{red}e[\textcolor{red}x := \textcolor{red}v]$ это выражение, где каждое свободное вхождение переменной $\textcolor{red}x$ заменено на выражение $\textcolor{red}v$.

Например, результатом $(λx.\; I\ I\ x)[I := λt.\; t]$ будет $λx.\; (λt.\;t)\ (λt.\;t)\ x$.

---

Но есть тонкость:

- $(λx.\; f\ x)[f := z]$ это $λx^0.\; z\ x^0$, где $z$ — свободная переменная
- Но если наивно подставить $f := z$ в $λz. f\ z$, то результатом будет $λz^0.\; z^0\ z^0$, где $z$ оказалась связана

Поэтому, подстановка должна давать новые имена связанным переменным, чьи имена совпадают с именами свободных переменных в подставляемом выражении.

И результатом $(λz.\; f\ z)[f := z]$ будет выражениие, где связанная переменная $z$ имеет другое имя — например, $λt.\; z\ t$.

---

С помощью подстановки можно сформулировать правила вычисления лямбда-выражений:

$$\begin{aligned}
(λ\textcolor{red}x.\;\textcolor{red}e)\ \textcolor{red}v &\longrightarrow_β {\textcolor{red}e}[{\textcolor{red}x := {\textcolor{red}v}}] & \text{(бета-редукция)} \\
(λ\textcolor{red}x.\; {\textcolor{red}f}\ {\textcolor{red}x}) &\longrightarrow_η {\textcolor{red}f} & \text{(эта-редукция)}
\end{aligned}$$

Применение правила это замена подвыражения (редекса), соответствующего левой части правила, выражением в правой части правила.

Эта-редукция применима только в том случае, когда в $\textcolor{red}f$ нет свободных вхождений переменной $\textcolor{red}x$.


---

Мы пишем ${\color{red}e_1} ⟶ {\color{red}e_2}$, если применение бета- или эта-редукции к ${\color{red}e_1}$ даёт выражение ${\color{red}e_2}$.

Мы пишем ${\color{red}e_1} \xrightarrow{*} {\color{red}e_2}$, если применение конечного числа (включая нуль)
редукций к выражению ${\color{red}e_1}$ даёт выражение ${\color{red}e_2}$.

Правила вычисления не говорят, какой именно редекс заменяется, и потому одно и то же выражение можно вычислять по разному:

$$\begin{aligned}
(λx\,y.\; x)\ ((λx.\;x)\ z) &⟶ λy.\; ((λx.\;x)\ z) &⟶ λy.\;z \\
(λx\,y.\; x)\ ((λx.\;x)\ z) &⟶ (λx\,y.\; x)\ z &⟶ λy.\;z
\end{aligned}$$

---

Несмотря на то, что вычислять можно по разному, всегда есть возможность придти к одному и тому же результату.

**Теорема (Чёрч — Россер):** Пусть ${\color{red}e} \xrightarrow{*} {\color{red}a}$ и ${\color{red}e} \xrightarrow{*} {\color{red}b}$. Тогда существует такое выражение $\color{red}c$, что ${\color{red}a} \xrightarrow{*} {\color{red}с}$ и ${\color{red}b} \xrightarrow{*} {\color{red}c}$.

Это важнейшая теорема лямбда-исчисления. Но доказывать мы её не будем.

Утверждение теоремы можно изобразить диаграммой.

---

![bg fit](images/church-rosser.png)

---

Выражение $\color{red}a$ вычислительно равно выражению $\color{red}b$ (пишется ${\color{red}a} \equiv {\color{red}b}$), если существует такое выражение $\color{red}c$, что ${\color{red}a} \xrightarrow{*} {\color{red}c}$ и ${\color{red}b} \xrightarrow{*} {\color{red}c}$.

Вычислительное равенство удовлетворяет основным свойствам эквивалентности:

- ${\color{red}e} ≡ {\color{red}e}$
- Если ${\color{red}a} \equiv {\color{red}b}$, то ${\color{red}b} \equiv {\color{red}a}$
- Если ${\color{red}a} ≡ {\color{red}b}$ и ${\color{red}b} ≡ {\color{red}c}$, то ${\color{red}a} ≡ {\color{red}c}$

Первые два свойства следуют непосредственно из определения. Последнее же следует из теоремы Чёрча — Россера, что проще всего показать диаграммой.

---

![bg fit](images/ceq-trans.png)

---

Выражение $\color{red}n$ находится в нормальной форме, если к нему невозможно применить правило вычисления.

Говорят, что $\color{red}n$ является нормальной формой выражения $\color{red}e$, если $\color{red}n$ находится в нормальной форме и  ${\color{red}e} \xrightarrow{*} {\color{red}n}$.

Из теоремы Чёрча — Россера следует, что у выражения может быть только одна нормальная форма. Кроме того, если два выражения имеют одну и ту же нормальную форму, то они вычислительно равны.

---

Не каждое выражение имеет нормальную форму:

$$\begin{aligned}
(λx.\;x\ x)\ (λx.\;x\ x) &⟶ (λx.\;x\ x)\ (λx.\;x\ x) &⟶ \dots \\
(λx.\;x\ x\ x)\ (λx.\;x\ x\ x) &⟶ (λx.\;x\ x\ x)\ (λx.\;x\ x\ x)\ (λx.\;x\ x\ x) &⟶ \dots
\end{aligned}$$

И даже если у выражения есть нормальная форма, не каждая стратегия вычисления к ней приводит:

$$\begin{aligned}
(λx\,y.\; y)\ ((λx.\;x\ x)\ (λx.\;x\ x)) &⟶ (λx\,y.\; y)\ ((λx.\;x\ x)\ (λx.\;x\ x)) &⟶ \dots \\
(λx\,y.\; y)\ ((λx.\;x\ x)\ (λx.\;x\ x)) &⟶ λy.\;y
\end{aligned}$$

Хотя теорема Чёрча — Россера гарантирует, что всегда есть способ достигнуть нормальной формы, она не заставляет ему следовать.

---

Мы ранее видели рекурсивные определения функции, и по аналогии можем ввести рекурсивные определения в лямбда-исчисление:

$$r := λx.\; {\color{red}e}\ r\ x$$

Однако, это не требуется, так как рекурсивные вычисления выразимы в лямбда исчислении без каких либо дополнительных расширений.

Чтобы понять, как, определим $r$ чуть иначе:

$$r := (λf.\;λx.\; {\color{red}e}\ f\ x)\ r$$

Чтобы выразить это определение в лямбда-исчислении, нужно найти такое выражение $r$, что

$$r \equiv (λf.\;λx.\; {\color{red}e}\ f\ x)\ r$$

---

Обобщаем задачу: ищем такое $Y$, что $Y\ f \equiv f\ (Y\ f)$. Чтобы его найти, вспомним выражение, что вычисляется в само себя:

$$(λx.\;x\ x)\ (λx.\;x\ x) ⟶ (λx.\;x\ x)\ (λx.\;x\ x)$$

Вставив в него $f$, получаем:

$$(λx.\;f\ (x\ x))\ (λx.\;f\ (x\ x)) ⟶ f\ ((λx.\;f\ x\ x)\ (λx.\;f\ x\ x))$$

Именно то, что и требовалось. Таким образом:

$$Y := λf.\;(λx.\;f\ (x\ x))\ (λx.\;f\ (x\ x))$$

Выражение $Y$ называется комбинатором неподвижной точки.

---

# Исчисление конструкций

---

Хотя используя лямбда-исчисление можно вычислить всё, что может быть вычисленно посредством переписывания символов на бумаге, в качестве основания математики оно непригодно.

Проблема заключается в том, что ничем не ограниченные ссылки на себя ведут к парадоксам. Например, рассмотрим утверждение:

$$L := \text{утверждение } L\ \text{ложно}$$

Если $L$ истино, то оно должно быть ложно, однако если $L$ ложно, то оно должно быть истино. Противоречие.

---

Кроме того, существут синтаксически корректные, но заведомо бессмысленные выражения. Например:

$$1\ (4 + λx.\;x)$$

Хотелось бы избежать необходимости рассуждать про бессмысленные выражения.

---

Обе проблемы решаются введением *типов*. Тип это класс значений по их происхождению. У каждого корректного выражения есть тип, и мы рассматриваем только те выражения, которые могут быть типизированы.

При этом, типы также являются выражениями, которые могут быть вычисленны.

Вместо безтипового лямбда-исчисления мы будем использовать формальную систему, называющуюся исчислением конструкций.

---

Синтаксис:

$$\begin{aligned}
expr ::=\ &var & &\text{(имя переменной)} \\
\mid\quad &“λ” \, var\ “{:}”\ expr\ “.”\ expr & &\text{(абстракция)} \\
\mid\quad &expr\ expr & &\text{(применение)} \\
\mid\quad &“\mathcal{U}”\ nat & &\text{(вселенная типов)} \\
\mid\quad &“∀” \, var\ “{:}”\ expr\ “.”\ expr & &\text{(тип функций)} \\
\end{aligned}$$

В абстракции появилось выражение после двоеточия. Это и есть тип переменной.

---

Кроме того:

- Вселенные типов пронумерованы натуральными числами: $\mathcal U\ 0$, $\mathcal U\ 1$, ...
- Как и $λ$, $∀$ также связывает переменные
- Тип $∀{\color{red}x}: {\color{red}α}.\; {\color{red}β}$ также записывается как $(\textcolor{red}x: {\color{red}α}) → {\color{red}β}$
  - Или даже как ${\color{red}α} → {\color{red}β}$, если в $\color{red}β$ нет свободных вхождений переменной $\color{red}x$
- $λ({\color{red}x}:{\color{red}α})({\color{red}y}:{\color{red}β}).\; {\color{red}e}$ означает $λ{\color{red}x}:{\color{red}α}.\;λ{\color{red}y}:{\color{red}β}.\; {\color{red}e}$
  - Аналогично для $∀({\color{red}x}:{\color{red}α})({\color{red}y}:{\color{red}β}).\; {\color{red}τ}$
- Стрелка правоассоциативна: ${\color{red}α} → {\color{red}β} → {\color{red}γ}$ означает ${\color{red}α} → ({\color{red}β} → {\color{red}γ})$

Правилом вычисления в исчислении конструкций является бета-редукция.

---

Мы рассматриваем только корректно типизированные выражения. Суждение о том, что выражение имеет определённый тип выводится с помощью правил вывода.

Правило, по которому из суждений $j_1$, …, $j_n$ можно вывести суждение $c$ записывается как

$$\frac{j_1\qquad \dots\qquad j_n}{c}$$

Если верхняя часть дроби пуста, то вывод заключения не требует предпосылок.

Правила вывода можно читать и наоборот: чтобы вывести $c$, нужно сначала вывести $j_1$, …, $j_n$.

---

Пример: пусть есть суждения вида ${\color{red}x} \sim {\color{red}y}$. И есть следующие правила вывода:

$$\frac{{\color{red}x} \sim {\color{red}y}}{{\color{red}y} \sim {\color{red}x}} \qquad
\frac{{\color{red}x} \sim {\color{red}y}\qquad {\color{red}y}\sim{\color{red}z}}{{\color{red}x} \sim {\color{red}z}}$$

Покажем, как из суждений $a \sim b$ и $a \sim c$ можно вывести $b \sim c$:

1. Предпосылки: $a \sim b$ и $a \sim c$
2. Применив второе правило к $a \sim b$, выводим $b \sim a$
3. Применив третье правило к $b \sim a$ и $a \sim c$, выводим $b \sim c$

---

Суждение, что в контексте $Γ$, выражение $\textcolor{red}x$ имеет тип $\textcolor{red}α$, записывается как

$$Γ ⊢ \textcolor{red}x:\textcolor{red}α$$

Контекст типизации это список пар вида ${\color{red}v}:{\color{red}τ}$, где $\color{red}v$ это переменная, а $\color{red}τ$ — её тип. Например:

$$(n:Nat), (x: Fin\ n), (f: α → β)$$

Мы пишем $Γ,({\color{red}v}:{\color{red}τ})$ чтобы присоединить пару ${\color{red}v}:{\color{red}τ}$ к контексту $Γ$.

---

Наконец, мы можем описать правила типизации.

Начальное правило проще описать словами: для каждой переменной ${\color{red}v}$, если из всех пар вида ${\color{red}v}:{\color{red}τ}$ пара ${\color{red}v}:{\color{red}α}$ является последней в $Γ$, то тогда $Γ ⊢ {\color{red}v}:{\color{red}α}$.

Например:

$$\begin{aligned}
(x:Nat), (α: \mathcal U\ 1), (x:α) &⊢ x:α \\
(x:Nat), (α: \mathcal U\ 1), (x:α) &⊢ α:\mathcal U\ 1
\end{aligned}$$

Следующее правило позволяет вычислять типы:

$$\frac
{ Γ ⊢ \textcolor{red}e: \textcolor{red}α\qquad
  \textcolor{red}α \equiv \textcolor{red}β\qquad
  Γ ⊢ \textcolor{red}β: \mathcal U\ i}
{Γ ⊢ \textcolor{red}e:\textcolor{red}β}$$

Здесь требуется, чтобы тип $\color{red}β$ был также корректно типизирован.

И наконец, перечислим правила типизации для выражений.

---

- Вселенные
$$\frac{}{Γ ⊢ \mathcal U\ i : \mathcal U\ (i + 1)}$$
- Тип зависимых функций
$$\frac{
  Γ ⊢ {\color{red}α}: \mathcal U\ i \qquad
  Γ,({\color{red}x}: {\color{red}α}) ⊢ {\color{red}β}: \mathcal U\ j
}{Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}): \mathcal U\ max(i,j)}$$
- Абстракция
$$\frac
{ Γ,({\color{red}x}:{\color{red}α}) ⊢ {\color{red}e}:{\color{red}β} \qquad
  Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\;{\color{red}β}):\mathcal U\ i      }
{Γ ⊢ (λ{\color{red}x}:{\color{red}α}.\;{\color{red}e}):
  (∀{\color{red}x}:{\color{red}α}.\;{\color{red}β})                        }$$
- Применение
$$\frac
{ Γ ⊢ {\color{red}f}:(∀{\color{red}x}:{\color{red}α}.\;{\color{red}β})\qquad
  Γ⊢ {\color{red}v}:{\color{red}α}                                           }
{Γ ⊢ ({\color{red} f\ v}): {\color{red}β}[{\color{red}x} := {\color{red}v}]}$$

---

Описав правила, можно сказать пару слов об их смысле:

- $f : ∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}$ означает, что $f$ можно применить только к значениям типа ${\color{red}α}$, а результатом является значение типа ${\color{red}β}$. При этом, тип результата может зависеть от аргумента функции
- У типа тоже есть тип, и этот тип мы называем вселенной типов
- $\mathcal U : \mathcal U$ приводит к парадоксу Жирара, и поэтому вместо одной вселенной у нас есть целая иерархия
$$\mathcal U\ 0 : \mathcal U\ 1 : \mathcal U\ 2 : \dots$$
- Причины, почему $∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}$ живёт в наибольшей из двух вселенных более тонкие, но тоже связаны с противоречивостью при некоторых дополнительных предположениях

---

Типизировнная версия выражения $λx\,y.\;x$ выглядит так:

$$\big(λ(α\, β:\mathcal U\ 1)(x:α)(y:β).\;x\big) : ∀α\,β:\mathcal U\ 1.\; α → β → α$$

Покажем, что выражение действительно имеет этот тип.

---

Применяя правила в обратном порядке, сначала покажем, что тип корректно типизирован:

$$\begin{aligned}
&⊢ (∀α\,β:\mathcal U\ 1.\; α → β → α): \mathcal U\ 2 \\
(α:\mathcal U\ 1) &⊢ (∀β:\mathcal U\ 1.\; α → β → α): \mathcal U\ 2 \\
(α:\mathcal U\ 1), (β:\mathcal U\ 1) &⊢ (α → β → α): \mathcal U\ 1 \\
(α:\mathcal U\ 1), (β:\mathcal U\ 1),({\color{red}u}:α) &⊢ (β → α): \mathcal U\ 1 \\
(α:\mathcal U\ 1), (β:\mathcal U\ 1),({\color{red}u}:α),({\color{red}v}:β) &⊢ β: \mathcal U\ 1 \\
(α:\mathcal U\ 1), (β:\mathcal U\ 1),({\color{red}u}:α),({\color{red}v}:β) &⊢ α: \mathcal U\ 1 \\
\end{aligned}$$

Суждения о вселенных опущены для краткости. $\color{red}u$ и $\color{red}v$ это неиспользованные параметры в типе функций.

---

Теперь покажем, что выражение действительно имеет требуемый тип:

$$\begin{aligned}
&⊢ \big(λ(α\, β:\mathcal U\ 1)(x:α)(y:β).\;x\big) : ∀α\,β:\mathcal U\ 1.\; α → β → α \\
(α:\mathcal U\ 1) &⊢ \big(λ(β:\mathcal U\ 1)(x:α)(y:β).\;x\big) : ∀β:\mathcal U\ 1.\; α → β → α \\
(α:\mathcal U\ 1),(β:\mathcal U\ 1) &⊢ \big(λ(x:α)(y:β).\;x\big) :  α → β → α \\
(α:\mathcal U\ 1),(β:\mathcal U\ 1),(x:α) &⊢ \big(λ(y:β).\;x\big) :  β → α \\
(α:\mathcal U\ 1),(β:\mathcal U\ 1),(x:α),(y:β) &⊢ x : α \\
\end{aligned}$$

Суждения о типах опущены, так как мы уже выводили их раньше.

Проверка типов — нудный, но полностью механический процесс.

---
