# Равенство

Одно и то же число может быть записано по разному:

$$4 \qquad 100 \qquad \mathrm{IV} \qquad ||||$$

Другой пример: два различных представления одного и того же *вещественного* числа:

$$0.999 \qquad 1$$

Карта не есть территория.

Что же является территорией в математике? Ответ может быть разным:

- Платонизм: некие сущности в мире идей
- Интуиционизм: представления в голове у идеализованного математика
- Формализм: территории нет, есть только символы

Можно также рассмотреть связь между символами и представлениями в голове у *реального* математика. Это соответствие неидеально — математик может считать, что некоторое утверждение истино (хотя не доказано), и затем вывести факт, что оно на самом деле ложно.

Но мы ожидаем, что то, что в символах, и то, что в голове постепенно сходится — математик корректирует свои представления по мере взаимодействия с символами, и в свою очередь меняет выраженные в символах предположения так, чтобы их следствия соответствовали желаемой картине.

Так или иначе, но хорошая карта сохраняет отношения между вещами — и мы можем рассматривать отношения как таковые как территорию.

Важнейшим из отношений является равенство. Интуитивно, мы можем описать его свойства так:

1. Любая вещь равна сама себе
2. Равные вещи неразличимы

Формально же, они соответствуют следующим постулатам:

$$\begin{aligned}
rfl &: ∀\{x:τ\}.\; x = x \\
ndrec &: ∀\{x:α\}\{M: α → \mathcal U\ i\}.\; M\ x → \{y: α\} → (x = y) → M\ y
\end{aligned}$$

$rfl$ выражает первое свойство буквально. Но эта буквальность с точностью до вычислительного равенства, так как вычислительно равные типы неразличимы. Так, например, $2 + 2 = 4$ и $4 = 4$ это один и тот же тип — оба выражения вычисляются в $4 = 4$.

Соответствие между вторым свойством и $ndrec$ тоньше. Пусть $P$ это какое-то свойство, которому могут удовлетворять значения типа $τ$. Если значения $x\, y: τ$ равны, то свойство $P$ не может их различить: если $P\ x$ истинно, то и $P\ y$ должно быть истинно, и наоборот. $ndrec$ обобщает это рассуждение до любого типа: если $x = y$, то любому значению $M\ x$ соответствует некоторое значение $M\ y$.

В Lean, равенство это индуктивное семейство типов:

```lean
inductive Eq : α → α → Prop where
  | refl (a : α) : Eq a a
```

Соответствующий рекурсор отличается от $ndrec$ лишь тем, что $M$ также принимает тип равенства в качестве аргумента:

```
Eq.rec: {a: α} → {M: (b: α) → a = b → Sort u} →
  M a (_: a = a) → {b: α} → (e: a = b) → M b e
```

Докажем несколько простых теорем о равенстве. Сначала докажем, что если $x = y$, то и $y = x$:

```lean
example {x y: α}(e: x = y): y = x :=
  Eq.ndrec (motive := λv => v = x) (rfl: x = x) e
```

Lean также позволяет записывать применение равенства как `e ▸ m`, с автоматическим выводом подходящего мотива:

```lean
example {x y: α}(e: x = y): y = x :=
  e ▸ (rfl: x = x)
```

Схожим образом доказываются и другие теоремы:

```lean
example {x y z: α}(xy: x = y)(yz: y = z): x = z :=
  yz ▸ xy

example {x y: α}{f: α → β}(e: x = y): f x = f y :=
  e ▸ (rfl: f x = f x)
```

Теперь покажем, как какие-либо два значения могут быть *не равны*. Конкретно, докажем, что $false ≠ true$.

Для этого сначала определим функцию, которая вычисляет тип `True`, если значения равны, и тип `False`, если не равны:

```lean
def BoolEq (a: Bool)(b: Bool): Prop :=
  a.rec (b.rec True False) (b.rec False True)
```

Мы можем доказать, что для любого `b:Bool` тип `BoolEq b b` населён. Для этого применяем рекурсор. Так как и `BoolEq false false`, и `BoolEq true true` вычислительно равны `True`, достаточно доказать `True` с помощью его единственного конструктора.

```lean
def bool_d: ∀b:Bool, BoolEq b b := Bool.rec ⟨⟩ ⟨⟩
```

Используя `bool_d`, доказываем абсурдность `false = true`:

```lean
theorem false_ne_true (h: false = true): False :=
   Eq.ndrec (bool_d false) h
```

Для каждого индуктивного типа `T` в `Type u`, Lean генерирует функции `T.noConfusionType` и `T.noConfusion`. Для значений типа `Bool` эти функции определены следующим образом:

```lean
def Bool.noConfusionType (P: Sort u)(x:Bool)(y:Bool): Sort u :=
  x.casesOn (y.casesOn (P → P) P) (y.casesOn P (P → P))

def Bool.noConfusion {P: Sort u}{x y : Bool}(xy: x = y): Bool.noConfusionType P x y :=
  Eq.ndrec (motive := λv => x = v → Bool.noConfusionType P x v)
    (λ(_: x = x) => x.casesOn (λa => a) (λa => a)) xy xy
```

Та же идея, что и у `false_ne_true`, но в несколько иной форме: вместо `False` — любое высказывание `P`, а вместо `True` функция `P → P`.

## Неразличимость доказательств

Пришло время показать, чем же `Prop` отличается от других вселенных типов. Во всех вселенных кроме `Prop` мы можем различить пару значений какого-либо типа:

```lean
example (P Q: Type)(pq: P ⊕ Q): Prop := pq.rec (λ_ => False) (λ_ => True)
```

Но мы не можем различить два значения типа в `Prop`. Например, нельзя так:

```lean
example (P Q: Prop)(pq: P ∨ Q): Prop := pq.rec (λ_ => False) (λ_ => True)
```

Lean запрещает применение рекурсора с мотивом за пределами `Prop`, если у индуктивного типа в `Prop` может быть больше чем одно значение.

Причиной этого ограничения является ещё одно свойство равенства: неразличимые вещи неотличимы от равных.

Ограничение на рекурсор делает невозможным доказательство неравенства двух значений любого типа в `Prop`. И отсутствие доказательств неравенства позволяет предположить обратное: любые два значения типа в `Prop` равны:

$$∀(P:Prop)(x: P)(y:P).\; x = y$$

Именно это Lean и делает. Более того, это не отдельная аксиома, а часть правил вывода — любые два значения в `Prop` *равны по определению*.

Таким образом, `inl p` и `inr q` это не два различных доказательства `P ∨ Q`, а различные представления одного и того же свидетельства истинности `P ∨ Q`.

Зачем уничтожать любое различие между значениями в `Prop`? На это есть две причины.

Первая из причин является ещё одним отличием `Prop` от остальных вселенных. Вспомним правило типизации для типов функций:

$$\frac{
  Γ ⊢ {\color{red}α}: \mathcal U\ i \qquad
  Γ,({\color{red}x}: {\color{red}α}) ⊢ {\color{red}β}: \mathcal U\ j
}{Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}): \mathcal U\ max(i,j)}$$

Но в случае, когда ${\color{red}β}: \mathcal U\ 0$, Lean использует другое правило:

$$\frac{
  Γ ⊢ {\color{red}α}: \mathcal U\ i \qquad
  Γ,({\color{red}x}: {\color{red}α}) ⊢ {\color{red}β}: \mathcal U\ 0
}{Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}): \mathcal U\ 0}$$

Например, `∀x:Nat, x = x` имеет тип `Prop` в Lean, хотя `Nat` имеет тип `Type`.

Это свойство вселенной `Prop` называется непредикативностью. Оно позволяет выражать некоторые высказывния, которые не могут быть выражены без него, и кроме того, позволяет высказывниям оставаться внутри `Prop`.

Вторая причина связана с использованием высказываний как критериев отбора значений. Пусть `P: α → Prop`. Будем рассматривать только те значения `x:α`, для которых `P x` истино. Им соответствует зависимые пары `⟨x, (p : P x)⟩`, тип которых определён следующим образом:

```lean
structure Subtype {α : Sort u} (p: α → Prop) where
  val : α
  property : p val
```

Этот тип называется подтипом типа `α` и также обозначается как `{x // P x}`.

Неразличимость доказательств делает соответствие между подходящими значениями `x:α` и парами `⟨x,p⟩` однозначным: хотя может быть множество способов доказать `P x`, они все представляют одно то же свидетельство истинности `P x`.

Рассмотрим пример. Пусть есть функция

```lean
def fls (_:Nat): Bool := false
```

Рассмотрим образ функции `fls`: булевы значения, каждое из которых является результатом применения `fls` к какому-то натуральному числу. Им соответствует тип `{b:Bool // ∃n, fls n = b}`.

Так как функция `fls` всегда вычисляется в `false`, то существует лишь одно значение типа `{b:Bool // ∃n, fls n = b}`. При этом, это значение может записываться по разному, например:

```lean
#check
  let I := {b:Bool // ∃n, fls n = b}
  let z:I := ⟨false, ⟨0, rfl⟩⟩
  let s:I := ⟨false, ⟨1, rfl⟩⟩
  (rfl : z = s)
```

Можно доказать, что все значения `x: {b:Bool // ∃n, fls n = b}` равны `⟨false, ⟨0, rfl⟩⟩`:

```lean
example (x: {b:Bool // ∃n, fls n = b}): x = ⟨false, ⟨0, rfl⟩⟩ :=
  x.recOn λb => b.recOn (λ_ => rfl) (λ⟨_, (e: false = true)⟩ => Bool.noConfusion e)
```

## Классическая логика

Логика, которую мы использовали всё время, называется конструктивной или интуиционистской. Классическая логика отличается от конструктивной дополнительной аксиомой: «любое высказывание либо истинно, либо ложно».

$$em:∀(p: Prop).\; p ∨ ¬p$$

Это принцип исключения третьего — более странное утверждение, чем кажется на первый взгляд. В любой достаточно выразительной формальной теории существуют выказывания, которые не могут быть ни доказаны, ни опровергнуты внутри этой теории — и тем не менее, и про такие высказывания $em$ говорит что они либо истины, либо ложны.

Несмотря на странность, для любого высказывания $P$, отрицание $P ∨ ¬P$ конструктивно ложно:

```lean
example {P: Prop}(nem: ¬(P ∨ ¬P)): False :=
  nem (Or.inr λp => nem (Or.inl p))
```

Высказывание $P$, для которого существует доказательство $¬¬P$, называется потенциально истинным.

Хотя любое высказывание потенциально либо истино, либо ложно, неверно, что потенциально любое высказывание либо истино, либо ложно: высказывание $¬¬(∀P:Prop.\; P ∨ ¬P)$ недоказуемо в конструктивной логике без дополнительных предположений.

В классической логике, $¬¬P$ равнозначно $P$: если отрицание абсурдно, то утверждение истинно.

Исключение третьего тесно связано с неразличимостью доказательств.

**Теорема ([парадокс Берарди](https://coq.inria.fr/library/Coq.Logic.Berardi.html)):** из непредикативности, исключения третьего, и возможности различать доказательства следует абсурд.

Доказывать эту теорему мы не будем.

---

Уровни конструктивности:

1. `Type`
2. `Prop`
3. `em`
4. `choice`
