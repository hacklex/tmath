# Механическое введение в математику

# Интро

(дыры размером в грузовой поезд)
(точность, недостижимая другими методами)

# Сущность подстановки

Рассмотрим запись:

$$f(x) = x^2 - 1$$

Чтобы вычислить значение функции в конкретной точке, достаточно подставить конкретное значение и вычислить результат. Например:

$$f(3) = 3^2 - 1 = 9 - 1 = 8$$

Другой пример — произведение чисел от одного до пяти:

$$\prod_{i=1}^{5} i= 1\cdot 2\cdot 3\cdot 4\cdot 5 = 120$$

В обоих случаях, чтобы вычислить результат, мы подставляем некоторые значения на место переменных в выражении.

Фундаментом всего для нас станет язык, основанный целиком на подстановке значений в переменные. Язык называется *лямбда-исчислением*, и в его синтаксисе есть всего четыре вещи:

- Переменные: $x$, $y$, $foo$, $bar$, …
- Абстракция: $\lambda x.\; E$, где $E$ это некоторое лямбда-выражение
- Применение: $F\ V$ — применение $F$ к $V$
- Круглые скобки для группировки выражений

Применение левоассоциативно: $F\ V_1\ V_2$ означает $(F\ V_1)\ V_2$. Кроме того, абстракция захватывает всё, что находится справа её. Запись $\lambda x\,y.\;E$ означает $\lambda x.\;\lambda y.\;E$.

В выражении $\lambda x.\; E$, переменная $x$ называется *связанной*. Если же переменную не связывает ни одна лямбда-абстракция, то переменная называется *свободной*. Например, в выражении $(\lambda x.\; y\ x)\ x$, переменная $x$ внутри абстракции связана, когда же переменная $y$ и переменная $x$ снаружи свободны.

Кроме синтаксиса, у лямбда-исчисления есть ещё и правила вычисления выражений:

- *β-редукция* это подстановка значения на место переменных. Например $(\lambda x.\;x\ x)\ (y\ z) \to_\beta (y\ z)\ (y\ z)$
- *η-редукция*: $(\lambda x.\; F\ x) \to_\eta F$

Здесь есть тонкости. В первую очередь, связанные переменные лишь указывают места, куда будет подставленно значение, и потому не имеет значения, как именно эти переменные названы. Поэтому, например, мы считаем $\lambda x.\;x$ и $\lambda t.\; t$ одними и теми же выражениями.

Кроме того, вычисляя выражение, мы не должны смешивать связанные переменные со свободными. То есть, так нельзя:

$$(\lambda x.\;\lambda y.\; x\ y)\ y \to_\beta \lambda y.\; y\ y$$

Мы должны переименовать связанную переменную $y$ так, чтобы она отличалась от свободных переменных в подставляемом выражении:

$$(\lambda x.\;\lambda y.\; x\ y)\ y \to_\alpha (\lambda x.\;\lambda t.\; x\ t)\ y \to_\beta \lambda t.\; y\ t \to_\eta y$$

Шаг с переименованием переменной называется α-конверсией.

Вместо того, чтобы считать лямбда-выражения руками, мы будем использовать [LCI](https://www.chatzi.org/lci/). В нём синтаксис выражений имеет следующий вид:

- Переменные: `x`, `y`, `foo`, `bar` — все начинаются со сточной буквы
- Абстракция: `\x. E`
- Применение: `F V`

В LCI можно связывать выражение с именем, например: `Id = \x.x` определяет `Id`. Определения должны начинаться с заглавной буквы.

В сложном выражении, правила вычисления можно применять по разному. LCI использует *нормальный порядок вычисления*, который из всех мест, где можно применить β-редукцию, выбирает наболее левое внешнее. Например:

$$(\lambda x.\; x\ x)\ ((\lambda y.\;y)\ z) \to_\beta ((\lambda y.\;y)\ z)\ ((\lambda y.\;y)\ z) \to_\beta z\ ((\lambda y.\;y)\ z) \to_\beta z\ z$$

Пусть $E$ это некоторое выражение, и пусть есть последовательность β или η редукций $E \to_{\beta\eta} \cdots \to_{\beta\eta} N$. Если ни одно из правил вычисления не применимо к $N$, то $N$ называется *нормальной формой* выражения $E$.

У нормального порядка вычисления есть важное свойство: если существует последовательность редукций, которое приводит выражение к нормальной форме, то и нормальный порядок вычисления приводит выражение к той же нормальной форме.

При всей своей простоте, лямбда-исчисления это полноценный язык программирование, на котором можно вычислить всё, что выразимо в любом другом языке программирования.

## Кодирование данных и рекурсия

Алгоритмы + структуры данных = программы. Мы начнём с того, как кодировать данные в лямбда-выражения. Ключевая идея здесь: данные это то, как их используют.

Начнём с простого: пара значений $a$ и $b$. Попробуем просто передать их в выражение:

$$(\lambda x\,y.\; E)\ a\ b$$

При вычислении $a$ подставляется вместо $x$, $b$ подставляется вместо $y$, и затем вычисляется само $E$. Но мы можем абстрагировать $(\lambda x\ y.\; E)$ в переменную:

$$(\lambda f.\; f\ a\ b)\ (\lambda x\,y.\; E)$$

Выражение $\lambda f.\; f\ a\ b$ и является закодированной парой значений $a$ и $b$. Мы можем определить конструктор пары:

$$Pair := \lambda x\,y.\;\lambda f.\; (f\ x\ y)$$

И затем писать просто $Pair\ a\ b$.

Теперь рассмотрим случай переменной, которая может принимать только два значения: $false$ и $true$. Алгоритм, который использует такую переменную рассматривает два случая:

- Пусть переменная равна $false$, тогда алгоритм вычисляет $L$
- Если же переменная равна $true$, то алгоритм вычисляет $R$

И мы можем сопоставить этим ситуациям следующие выражения:

- $(\lambda f\,t.\; f)\ L\ R \to_\beta L$
- $(\lambda f\,t.\; t)\ L\ R \to_\beta R$

Выражения $False := \lambda f\,t.\; f$ и $True := \lambda f\,t.\; t$ и являются закодированными значениями $false$ и $true$.

Теперь у нас есть всё, чтобы закодировать натуральные числа. Любое натуральное число можно представить
в виде суммы нуля и единиц:

$$
\begin{aligned}
3 &= 0 + 1 + 1 + 1 \\
5 &= 0 + 1 + 1 + 1 + 1 + 1
\end{aligned}
$$

И мы кодируем число с помощью двух конструкторов

- $Z$ соответствует нулю
- $S\ n$, где $n$ это натуальное число, соответствует $n+1$

Конструкторы определяем так:

$$Z := \lambda z\, s.\; z \qquad S:= \lambda n.\; \lambda z\,s.\; (s\ n)$$

Кроме натуральный чисел, полезно ещё определить списки:

- $Nil$ соответствует пустому списку
- $Cons\ x\ xs$ соответствует списку, первый элемент которого $x$, а затем идут элементы списка $xs$

Пример: список $[1, 2, 3]$ можно записать как $Cons\ 1\ (Cons\ 2\ (Cons\ 3\ Nil))$.

Конструкторы списка определяются так:

$$Nil := \lambda nil\, cons.\; nil \qquad Cons := \lambda x\,xs.\; \lambda nil\,cons.\; (cons\ x\ xs)$$

Данные у нас есть, теперь нужны алгоритмы. В математике мы часто выражаем их с помощью рекурсии:

$$fact := \begin{cases}
0 \mapsto 1 \\
n \mapsto n \cdot fact(n - 1)
\end{cases}$$

В лямбда исчислении у нас явной рекурсии нет. Но мы можем выразить её неявно. Для этого сначала выразим $fact$ с помощью кодирования, что у нас есть, полагая, что умножение определено:

$$fact = \lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (fact\ k))$$

Здесь $k$ соответствует числу $n-1$. Теперь абстрагируем $fact$ в выражении:

$$fact = (\lambda f.\;\lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (f\ k)))\ fact$$

Обозначим $F := (\lambda f.\;\lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (f\ k)))$. Тогда определение $fact$ разворачивается следующим образом:

$$fact \to F\ fact \to F\ (F\ fact) \to \cdots$$

Если мы определим функцию $Y$, такую, что $Y\ f \to_\beta f\ (Y\ f)$, то мы сможем вычислить $fact\ n$. Чтобы вывести $Y$, посмотрим, как эта функция действует на саму себя:

$$Y\ Y \to_\beta Y\ (Y\ Y) \to_\beta \cdots$$

Нетрудно найти функцию, которая действует на $Y$ как $Y$:

$$(\lambda y.\; Y\ (y\ y))\ Y \to_\beta Y\ (Y\ Y)$$

Но что если мы применим эту функцию к самой себе?

$$(\lambda y.\; Y\ (y\ y))\ (\lambda y.\; Y\ (y\ y)) \to_\beta Y \ \big((\lambda y.\; Y\ (y\ y))\ (\lambda y.\; Y\ (y\ y))\big)$$

Редукция этого выражения уже не зависит от определения $Y$. То же самое работает и для $F$:

$$(\lambda y.\; F\ (y\ y))\ (\lambda y.\; F\ (y\ y)) \to_\beta F \ \big((\lambda y.\; F\ (y\ y))\ (\lambda y.\; F\ (y\ y))\big)$$

Так что мы можем определить $Y$ следующим образом:

$$Y := \lambda f.\; (\lambda y.\; f\ (y\ y))\ (\lambda y.\; f\ (y\ y))$$

Функция $Y$ называется оператором неподвижной точки. Посмотрим на примере факториала, как он работает:

$$\begin{aligned}
Y\ F\ 3 &\to_\beta F\ (Y\ F)\ 3 \\
&\to_\beta mul\ 3\ (Y\ F\ 2) \\
&\to_\beta mul\ 3\ (F\ (Y\ F)\ 2) \\
&\to_\beta mul\ 3\ (mul\ 2\ (Y\ F\ 1) ) \\
&\to_\beta mul\ 3\ (mul\ 2\ (F\ (Y\ F)\ 1) ) \\
&\to_\beta mul\ 3\ \big(mul\ 2\ (mul\ 1\ (Y\ F\ 0))\big) \\
&\to_\beta mul\ 3\ \Big(mul\ 2\ \big(mul\ 1\ (F\ (Y\ F)\ 0)\big)\Big) \\
&\to_\beta mul\ 3\ (mul\ 2\ (mul\ 1\ 1)) \\
&\twoheadrightarrow_\beta 6
\end{aligned}$$

В LCI можно использовать явную рекурсию вместо оператора неподвижной точки.

Имея рекурсию, мы можем определить сложение:

$$add := \lambda n\,k.\; k\ 0\ (\lambda pk.\;S\ (add\ n\ pk))$$

И все остальные вычислимые функции.

## Типы

Не все выражения имеют нормальную форму. Например, сам оператор $Y$ не имеет нормальной формы.

Вопрос о том, имеет ли произвольное выражение нормальную форму или нет аналогичен знаменитой проблеме останова и *алгоритмически неразрешим*. То есть, не может существовать такого алгоритма, который бы для любого лямбда-выражение возвращал $true$, если выражение имеет нормальную форму, и $false$, если не имеет.

Это не является большой проблемой в программировании, но недопустимо в математике, где самореферетные определения могут порождать парадоксы.

Кроме отсутствия нормальной формы, есть ещё и другая проблема: данные вроде «$true$ или $false$» и «$heads$ или $tails$» кодируются совершенно одинаково в лямбда-исчислении. Нам бы хотелось различать сорта данных: логический $Bool := true \mathbin| false$, стороны монеты $Coin := heads \mathbin| tails$,
числа $Nat := Z \mathbin| Suc(Nat)$, и так далее. Однако, введение дополнительных сущностей приводит к бессмысленным выражениям вроде $tails - 42$.

Чтобы решить обе проблемы, нужно ограничить множество выражений, которые мы считаем осмысленными. Для этого используются *типы.*

## Lean

# Механическая логика

## Предикаты и кванторы

## Тактики

# Основы математики

## Функции

## Множества

---

Существуют *выражения.* Например: `42`, `2+3` или `[5, 4, 3]`.

Каждое выражение помечено единственным *типом.* Например, `42 : Nat`, `2+3 : Nat`
и `[5, 4, 3] : List Nat`.

Хотя каждое выражение имеет тип, не у каждого типа есть какое-либо выражение этого типа.
Тип называется населённым, если существует хотя бы одно выражение этого типа.

Тип также является выражением и имеет тип: `nat : Type`, `Type : Type 1`, `Type 1 : Type 2`.

Выражения могут вычислятся в другие выражения. Например, `2+3` вычисляется в `5`.
Вычисление это применение функции к аргументам. Например, в выражении `2+3`, функция `(+)`
применяется к аргументам `2` и `3`. Результат применения функции к её аргументам называется
результатом функции.

У функции есть тип. Если `x : A` и `f x : B`, то функция `f` должна иметь тип `f : A → B`.

Функции можно определять с помощью лямбда-абстракции. Например, `λ x => x + x`.
Применение лямбда-функции к аргументу вычисляется в выражение, где на места соответствующей
переменной подставляется аргумент функции. Например, `(λ x => x + x) 3` вычисляется
в `3 + 3`.

Результатом функции может быть другая функция, а аргументы функции могут также быть функциями.

Тип результата функции может зависить от значения, к которому функция применяется.
В таком случае говорят, что функция имеет зависимый тип. Такой тип записывается
как `∀x: A, B x` или `(x : A) → B x`.

## Механизированная логика

Высказывание `P` это тип. Значение типа `P` это свидетельство истинности `P`.

Элементарное высказывание имеет тип `Prop`. Утверждение, что из `P` следует `Q`
это тип `P → Q`.

Утверждение, что и `P` и `Q` истинны это тип `P ∧ Q`. Утверждение, что по крайней мере
из `P` и `Q` по крайней мере одно является истинным это тип `P ∨ Q`.

Ложь или абсурд это незаселённый тип `false`. Отрицание `P` это тип `P → false` (записываемый
ещё как `¬P`).
