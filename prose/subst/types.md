Не все выражения имеют нормальную форму. Например, сам оператор $Y$ не имеет нормальной формы.

Вопрос о том, имеет ли произвольное выражение нормальную форму или нет аналогичен знаменитой проблеме останова и *алгоритмически неразрешим*. То есть, не может существовать такого алгоритма, который бы для любого лямбда-выражение возвращал $true$, если выражение имеет нормальную форму, и $false$, если не имеет.

Это не является большой проблемой в программировании, но недопустимо в математике, где самореферетные определения могут порождать парадоксы.

Кроме отсутствия нормальной формы, есть ещё и другая проблема: данные вроде «$true$ или $false$» и «$heads$ или $tails$» кодируются совершенно одинаково в лямбда-исчислении. Нам бы хотелось различать сорта данных: логический $Bool := true \mathbin| false$, стороны монеты $Coin := heads \mathbin| tails$,
числа $Nat := Z \mathbin| Suc(Nat)$, и так далее. Однако, введение дополнительных сущностей приводит к бессмысленным выражениям вроде $tails - 42$.

Чтобы решить обе проблемы, нужно ограничить множество выражений, которые мы считаем осмысленными. Для этого используются *типы.*
