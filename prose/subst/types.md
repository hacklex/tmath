Не все выражения имеют нормальную форму. Например, сам оператор $Y$ не имеет нормальной формы.

Вопрос о том, имеет ли произвольное выражение нормальную форму или нет аналогичен знаменитой проблеме останова и *алгоритмически неразрешим*. То есть, не может существовать такого алгоритма, который бы для любого лямбда-выражение возвращал $true$, если выражение имеет нормальную форму, и $false$, если не имеет.

Это не является большой проблемой в программировании, но недопустимо в математике, где самореферетные определения могут порождать парадоксы.

Кроме отсутствия нормальной формы, есть ещё и другая проблема: данные вроде «$true$ или $false$» и «$heads$ или $tails$» кодируются совершенно одинаково в лямбда-исчислении. Нам бы хотелось различать сорта данных: логический $Bool := true \mathbin| false$, стороны монеты $Coin := heads \mathbin| tails$,
числа $Nat := Z \mathbin| Suc(Nat)$, и так далее. Однако, введение дополнительных сущностей приводит к бессмысленным выражениям вроде $tails - 42$.

Чтобы решить обе проблемы, нужно ограничить множество выражений, которые мы считаем осмысленными. Для этого используются *типы.*

Рассмотрим сначала просто типизированное лямбда-исчисление. Синтаксис выражений:

- Переменные: $x$, $y$, $foo$, $bar$, ...
- Абстракция: $\lambda x: \tau.\; E$, где $\tau$ -- тип
- Применение: $F\ V$
- Скобки для группировки

В синтаксисе абстракции появилось указание типа. Теперь синтаксис типов:

- Заданные изначально базовые типы. Например: $Nat$, $Unit$, $Void$, ...
- Тип функций $\sigma \to \tau$, где $\sigma$ и $\tau$ это типы
- Скобки

Мы пишем $\alpha \to \beta \to \gamma$ имея в виду $\alpha \to (\beta \to \gamma)$.

В отличие от бестипового лямбда исчисления, мы рассматриваем не все возможные выражения, а только корректно типизированные. То, является ли выражение корректно типизированным, определяется с помощью *правил типизации*.

Но сначала нам потребуется понятие *окружения типизации*. Окружение $\Gamma$ это список пар вида $x : \tau$, связывающих переменную с её типом. Например:

$$\Gamma = [x: Nat,\ add: Nat \to Nat]$$

В этом окружении переменная $x$ имеет тип $Nat$, когда же переменная $add$ имеет тип $Nat \to Nat \to Nat$.

Мы говорим, что переменная $x$ имеет тип $\tau$ в окружении $\Gamma$, если среди всех пар с переменной $x$ последняя из них содержит тип $\tau$. Записывается это как $\Gamma \vdash x: \tau$.

Например, пусть окружение имеет вид:

$$\Gamma = [x:\alpha,\ y:\beta,\ x: \gamma,\ z: \alpha]$$

Тогда $\Gamma \vdash x:\gamma$, $\Gamma\vdash y: \beta$ и $\Gamma\vdash z:\alpha$. При этом неверно, что $\Gamma\vdash x:\alpha$, так как пара $x:\alpha$ не является последней среди всех пар, определяющих тип переменной $x$.

Запятая добавляет переменную в контекст:

$$[x:\tau],\,y: \sigma = [x: \tau,\ y:\sigma]$$

Теперь мы можем определить правила типизации, определяющие тип выражения в данном окружении типизации $\Gamma$:

- Абстракция: если в окружении $\Gamma, x: \sigma$ выражение $E$ имеет тип $\tau$, то в окружении $\Gamma$ выражение $\lambda x: \sigma.\; E$ имеет тип $\sigma \to \tau$
- Применение: если в окружении $\Gamma$, $F$ имеет тип $\sigma \to \tau$ и $V$ имеет тип $\sigma$, то
в окружении $\Gamma$ выражение $F\ V$ имеет тип $\tau$

Рассмотрим пример. Пусть дано окружение:

$$\Gamma = [z:Nat,\ s: Nat \to Nat,\ add: Nat \to Nat \to Nat]$$

Покажем, что выражение $(\lambda n: Nat.\; add\ n\ (s\ z))\ z$ имеет тип $Nat$:

1. Так как $\Gamma\vdash z: Nat$, достаточно показать, что $\Gamma\vdash (\lambda n: Nat.\; add\ n\ (s\ z)) : Nat \to Nat$
2. Для этого достаточно показать, что $\Gamma, n: Nat \vdash add\ n\ (s\ z) : Nat$
3. $\Gamma, n: Nat \vdash add : Nat \to Nat \to Nat$, так что достаточно показать, что $\Gamma, n: Nat \vdash n: Nat$ и $\Gamma, n: Nat \vdash s\ z: Nat$
    1. Первое очевидно
    2. Второе следует из того, что $\Gamma, n: Nat \vdash z: Nat$ и $\Gamma, n: Nat \vdash s: Nat \to Nat$

Таким образом, данное выражение является корректно типизированным. Но бывают выражения, которые не могут быть просто типизированны ни в каком окружении. Например, рассмотрим выражение $t\ t$:

- Предположим, что $\Gamma\vdash t: \sigma$
- Но тогда из правила для применения следует, что $\Gamma\vdash t: \tau \to \sigma_1$, где $\sigma_1$ это какой-то тип
- Но тогда $\Gamma\vdash t : (\tau \to \sigma_1) \to \sigma_2$
- Поскольку так можно продолжать до бесконечности, переменной $t$ не может быть присвоен какой-то корректный тип

На самом деле, любое просто типизированное выражение имеет нормальную форму. Из этого следует, что оператор неподвижной точки невыразим в просто типизированном лямбда исчислении.

Просто типизированное лямбда-исчисление недостаточно выразительно, чтобы записать обобщенные функции. Так, $\lambda x: \sigma.\; x$ и $\lambda x: \tau.\; x$ это тождественные функции для двух различных типов, но при этом невозможно выразить тождественную функцию для всех типов.

Чтобы определять обобщённые функции, мы вводим абстракцию для типов. Для этого мы добавляем следующую конструкцию в синтаксис типов:

$$∀α: Type.\; τ$$

И следующую конструкцию в синтаксис выражений:

$$\lambda α: Type.\; E$$

Теперь мы можем выразить тождественную функцию следующим образом: $\lambda \alpha : Type.\; \lambda x: \alpha.\; x$. При этом она имеет тип $\forall α: Type.\; α → α$.

Запись $\sigma[α := \tau]$ означает тип $σ$, где на места всех свободных переменных $α$ подставляется тип $τ$.

Вместе с новым синтаксисом появляются дополнительные правила типизации:

- Введение ∀:
    - Если $\Gamma, τ: Type \vdash M : \boldsymbol{\alpha}$
    - Тогда $\Gamma \vdash (\lambda \tau: Type.\; M): (\forall \tau.\; \sigma)$
- Удаление ∀
    - Eсли $Γ \vdash M : (∀α: Type.\; σ)$
    - И $\Gamma \vdash τ: Type$
    - Тогда $Γ \vdash (M\  \tau) : \sigma[α := \tau]$
