Рассмотрим запись:

$$f(x) = x^2 - 1$$

Чтобы вычислить значение функции в конкретной точке, достаточно подставить конкретное значение и вычислить результат. Например:

$$f(3) = 3^2 - 1 = 9 - 1 = 8$$

Другой пример — произведение чисел от одного до пяти:

$$\prod_{i=1}^{5} i= 1\cdot 2\cdot 3\cdot 4\cdot 5 = 120$$

В обоих случаях, чтобы вычислить результат, мы подставляем некоторые значения на место переменных в выражении.

Фундаментом всего для нас станет язык, основанный целиком на подстановке, назваемый лямбда-исчислением. Вот его синтаксис:

$$\begin{aligned}
expr ::=\ &var & &\text{(имя переменной)} \\
\mid\quad &“λ” \, var\ “.”\ expr & &\text{(абстракция)} \\
\mid\quad &expr\ expr & &\text{(применение)}
\end{aligned}$$

Имя переменной может содержать более одного символа: $foo$ и $bar$ это тоже корректные имена. Мы различаем строчные буквы от заглавных, то есть $ab$ и $aB$ это два разных имени.

Применение левоассоциативно: ${?f}\ {?v_1}\ {?v_2}$ означает $({?f}\ {?v_1})\ {?v_2}$. Кроме того, абстракция захватывает всё, что находится справа её.

Ещё мы будем использовать следующее сокращение: 
- $λ{?v_1}\,{?v_2}.\; ?e$ означает $λ{?v_1}.\;(λ{?v_2}.\; {?e})$.
- $λ{?v_1}\,{?v_2}\,{?v_3}.\; ?e$ означает $λ{?v_1}.\;(λ{?v_2}.\; (λ{?v_3}.\;{?e}))$.
- И так далее

Например, $λ x\, y.\; x$ это то же самое, что и $λx.\; λ y.\; x$.

Смысл: абстракция определяет анонимную функцию, когда же применение подставляет значение в тело функции, тем самым применяя функцию к аргументу. Например, в лямбда исчислении, расширенным арифметическими операциями, выражение $(\lambda x.\; x^2 - 1)\ 5$ сначала раскрывается как в $5^2 - 1$ и затем вычисляется в $24$.

Однако, есть тонкости. Например выражение $(λx.\; λx.\; x)\ y$ должно вычисляться в $λx.\; x$, а не в $λ x.\; y$, так как переменная $x$ связана с ближайшей к ней абстракции -- с внутренней, при этом внешная не связывает никакую переменную. Другая тонкость: связанные переменные лишь указывают место подстановки выражения, и в случае необходимости должны быть переименованы: так, выражение $(λ x.\;λ y.\; x\ y)\ y$ вычисляется в $\lambda t.\; y\ t$.

Чтобы строго определить подстановку, нам потребуются некоторые операции над выражениями. Результат обмена переменных $?x$ и $?y$ в выражении $?t$ (пишется $(?x\ ?y) \cdot {?t}$) это выражение, определённое следующим образом:

- Если $?t$ это переменная, то
    - Если имена $?t$ и $?x$ совпадают, то результатом является переменная $?y$
    - Если имена $?t$ и $?y$ совпадают, то результатом является $?x$
    - Иначе $?t$ остаётся неизменным
- Если $?t$ это применение $?f\ ?a$, то результатом является $\{(?x\ ?y) \cdot {?f}\}\ \{(?x\ ?y) \cdot {?a}\}$
- Если $?t$ это абстракция $λ\, ?v.\;?e$, то результат это $\lambda\, \{(?x\ ?y) \cdot {?v}\}.\; \{(?x\ ?y) \cdot{?e}\}$

Например, $(x\ y) \cdot λx.\; x\ y\ z$ это $λy.\; y\ x\ z$.

Мы говорим, что переменная $?x$ является свежей в выражении $?e$ (пишется $?x \mathbin{\#} {?e}$) если эта переменная не встречается в выражении $?e$. Например, в выражении $λx.\; y\ x$ переменные $z$ и $t$ являются свежимм, когда же переменные $x$ и $y$ -- не являются.

Используя обмен переменных и свежие переменные, мы можем определить аналог равенства, не учитывающий имена связанных переменных, но учитывающих соответствующие им места подстановки.

Альфа-эквивалентность определяется с помощью следующих правил:

- ${?v} =_α {?v}$ для любой переменной $?v$
- $$\frac{?f_1 =_α {?f_2} \qquad?a_1 =_α {?a_2}}{{?f_1}\ ?a_1 =_α {?f_2}\ ?a_2}$$
- $$\frac{?y \mathbin\# {?e_1} \quad ?y \mathbin\# {?e_2} \quad (?x_1\ ?y)\cdot {?e_1} =_α (?x_2\ ?y)\cdot {?e_2}} {λ\, ?x_1.\; ?e_1 =_α λ\, ?x_2.\;?e_2}$$

---

В выражении $λ x.\; E$, переменная $x$ называется *связанной*. Если же переменную не связывает ни одна лямбда-абстракция, то переменная называется *свободной*. Например, в выражении $(λ x.\; y\ x)\ x$, переменная $x$ внутри абстракции связана, когда же переменная $y$ и переменная $x$ снаружи свободны.

Кроме синтаксиса, у лямбда-исчисления есть ещё и правила вычисления выражений:

- *β-редукция* это подстановка значения на место переменных. Например $(λ x.\;x\ x)\ (y\ z) \to_\beta (y\ z)\ (y\ z)$
- *η-редукция*: $(λ x.\; F\ x) \to_\eta F$

Здесь есть тонкости. В первую очередь, связанные переменные лишь указывают места, куда будет подставленно значение, и потому не имеет значения, как именно эти переменные названы. Поэтому, например, мы считаем $λ x.\;x$ и $λ t.\; t$ одними и теми же выражениями.

Кроме того, вычисляя выражение, мы не должны смешивать связанные переменные со свободными. То есть, так нельзя:

$$(λ x.\;λ y.\; x\ y)\ y \to_\beta λ y.\; y\ y$$

Мы должны переименовать связанную переменную $y$ так, чтобы она отличалась от свободных переменных в подставляемом выражении:

$$(λ x.\;λ y.\; x\ y)\ y \to_\alpha (λ x.\;λ t.\; x\ t)\ y \to_\beta λ t.\; y\ t \to_\eta y$$

Шаг с переименованием переменной называется α-конверсией.

Вместо того, чтобы считать лямбда-выражения руками, мы будем использовать [LCI](https://www.chatzi.org/lci/). В нём синтаксис выражений имеет следующий вид:

- Переменные: `x`, `y`, `foo`, `bar` — все начинаются со сточной буквы
- Абстракция: `\x. E`
- Применение: `F V`

В LCI можно связывать выражение с именем, например: `Id = \x.x` определяет `Id`. Определения должны начинаться с заглавной буквы.

В сложном выражении, правила вычисления можно применять по разному. LCI использует *нормальный порядок вычисления*, который из всех мест, где можно применить β-редукцию, выбирает наболее левое внешнее. Например:

$$(λ x.\; x\ x)\ ((λ y.\;y)\ z) \to_\beta ((λ y.\;y)\ z)\ ((λ y.\;y)\ z) \to_\beta z\ ((λ y.\;y)\ z) \to_\beta z\ z$$

Пусть $E$ это некоторое выражение, и пусть есть последовательность β или η редукций $E \to_{\beta\eta} \cdots \to_{\beta\eta} N$. Если ни одно из правил вычисления не применимо к $N$, то $N$ называется *нормальной формой* выражения $E$.

У нормального порядка вычисления есть важное свойство: если существует последовательность редукций, которое приводит выражение к нормальной форме, то и нормальный порядок вычисления приводит выражение к той же нормальной форме.

При всей своей простоте, лямбда-исчисления это полноценный язык программирование, на котором можно вычислить всё, что выразимо в любом другом языке программирования.
