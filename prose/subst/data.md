Алгоритмы + структуры данных = программы. Мы начнём с того, как кодировать данные в лямбда-выражения. Ключевая идея здесь: данные это то, как их используют.

Начнём с простого: пара значений $a$ и $b$. Попробуем просто передать их в выражение:

$$(\lambda x\,y.\; E)\ a\ b$$

При вычислении $a$ подставляется вместо $x$, $b$ подставляется вместо $y$, и затем вычисляется само $E$. Но мы можем абстрагировать $(\lambda x\ y.\; E)$ в переменную:

$$(\lambda f.\; f\ a\ b)\ (\lambda x\,y.\; E)$$

Выражение $\lambda f.\; f\ a\ b$ и является закодированной парой значений $a$ и $b$. Мы можем определить конструктор пары:

$$Pair := \lambda x\,y.\;\lambda f.\; (f\ x\ y)$$

И затем писать просто $Pair\ a\ b$.

Теперь рассмотрим случай переменной, которая может принимать только два значения: $false$ и $true$. Алгоритм, который использует такую переменную рассматривает два случая:

- Пусть переменная равна $false$, тогда алгоритм вычисляет $L$
- Если же переменная равна $true$, то алгоритм вычисляет $R$

И мы можем сопоставить этим ситуациям следующие выражения:

- $(\lambda f\,t.\; f)\ L\ R \to_\beta L$
- $(\lambda f\,t.\; t)\ L\ R \to_\beta R$

Выражения $False := \lambda f\,t.\; f$ и $True := \lambda f\,t.\; t$ и являются закодированными значениями $false$ и $true$.

Теперь у нас есть всё, чтобы закодировать натуральные числа. Любое натуральное число можно представить
в виде суммы нуля и единиц:

$$
\begin{aligned}
3 &= 0 + 1 + 1 + 1 \\
5 &= 0 + 1 + 1 + 1 + 1 + 1
\end{aligned}
$$

И мы кодируем число с помощью двух конструкторов

- $Z$ соответствует нулю
- $S\ n$, где $n$ это натуальное число, соответствует $n+1$

Конструкторы определяем так:

$$Z := \lambda z\, s.\; z \qquad S:= \lambda n.\; \lambda z\,s.\; (s\ n)$$

Кроме натуральный чисел, полезно ещё определить списки:

- $Nil$ соответствует пустому списку
- $Cons\ x\ xs$ соответствует списку, первый элемент которого $x$, а затем идут элементы списка $xs$

Пример: список $[1, 2, 3]$ можно записать как $Cons\ 1\ (Cons\ 2\ (Cons\ 3\ Nil))$.

Конструкторы списка определяются так:

$$Nil := \lambda nil\, cons.\; nil \qquad Cons := \lambda x\,xs.\; \lambda nil\,cons.\; (cons\ x\ xs)$$

Данные у нас есть, теперь нужны алгоритмы. В математике мы часто выражаем их с помощью рекурсии:

$$fact := \begin{cases}
0 \mapsto 1 \\
n \mapsto n \cdot fact(n - 1)
\end{cases}$$

В лямбда исчислении у нас явной рекурсии нет. Но мы можем выразить её неявно. Для этого сначала выразим $fact$ с помощью кодирования, что у нас есть, полагая, что умножение определено:

$$fact = \lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (fact\ k))$$

Здесь $k$ соответствует числу $n-1$. Теперь абстрагируем $fact$ в выражении:

$$fact = (\lambda f.\;\lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (f\ k)))\ fact$$

Обозначим $F := (\lambda f.\;\lambda n.\; n\ 1\ (\lambda k.\; mul\ n\ (f\ k)))$. Тогда определение $fact$ разворачивается следующим образом:

$$fact \to F\ fact \to F\ (F\ fact) \to \cdots$$

Если мы определим функцию $Y$, такую, что $Y\ f \to_\beta f\ (Y\ f)$, то мы сможем вычислить $fact\ n$. Чтобы вывести $Y$, посмотрим, как эта функция действует на саму себя:

$$Y\ Y \to_\beta Y\ (Y\ Y) \to_\beta \cdots$$

Нетрудно найти функцию, которая действует на $Y$ как $Y$:

$$(\lambda y.\; Y\ (y\ y))\ Y \to_\beta Y\ (Y\ Y)$$

Но что если мы применим эту функцию к самой себе?

$$(\lambda y.\; Y\ (y\ y))\ (\lambda y.\; Y\ (y\ y)) \to_\beta Y \ \big((\lambda y.\; Y\ (y\ y))\ (\lambda y.\; Y\ (y\ y))\big)$$

Редукция этого выражения уже не зависит от определения $Y$. То же самое работает и для $F$:

$$(\lambda y.\; F\ (y\ y))\ (\lambda y.\; F\ (y\ y)) \to_\beta F \ \big((\lambda y.\; F\ (y\ y))\ (\lambda y.\; F\ (y\ y))\big)$$

Так что мы можем определить $Y$ следующим образом:

$$Y := \lambda f.\; (\lambda y.\; f\ (y\ y))\ (\lambda y.\; f\ (y\ y))$$

Функция $Y$ называется оператором неподвижной точки. Посмотрим на примере факториала, как он работает:

$$\begin{aligned}
Y\ F\ 3 &\to_\beta F\ (Y\ F)\ 3 \\
&\to_\beta mul\ 3\ (Y\ F\ 2) \\
&\to_\beta mul\ 3\ (F\ (Y\ F)\ 2) \\
&\to_\beta mul\ 3\ (mul\ 2\ (Y\ F\ 1) ) \\
&\to_\beta mul\ 3\ (mul\ 2\ (F\ (Y\ F)\ 1) ) \\
&\to_\beta mul\ 3\ \big(mul\ 2\ (mul\ 1\ (Y\ F\ 0))\big) \\
&\to_\beta mul\ 3\ \Big(mul\ 2\ \big(mul\ 1\ (F\ (Y\ F)\ 0)\big)\Big) \\
&\to_\beta mul\ 3\ (mul\ 2\ (mul\ 1\ 1)) \\
&\twoheadrightarrow_\beta 6
\end{aligned}$$

В LCI можно использовать явную рекурсию вместо оператора неподвижной точки.

Имея рекурсию, мы можем определить сложение:

$$add := \lambda n\,k.\; k\ 0\ (\lambda pk.\;S\ (add\ n\ pk))$$

И все остальные вычислимые функции.
